------------------------------------------------------------------------------------------ 1. Getting Started

Why use a version control ?

Types of version control? How it evolved.

Local Version control  
	rcs - stores difference b.w versions and when you want a version, joins all of them and give you the file
Central Version control 
	When a lot of developers started working on the same code and started contributing to the same project, 
	the need of central vcs was visioned. 
	Advantage it brought was everyone in the project knew to certain degree what ever1 else in the project was doing.
	The big issue with it was SINGLE POINT OF FAILURE. You risk everything, as all your main project is at single place.
Distributed Version control
	This is where the distributed vcs stepped in. 
	In a DVCS, clients don't just checkout the latest snapshot of the files but they fully mirror/clone the repository.
	Thus if any server dies then any of the client server can be restored there. Every checkout is a full backup of all data.

History of Git - 
Linux Kernel, an open source soft project was manitained by software patches and archived files till 2002.
After 2002, a linux kernel project BitProject(DVCS) begain to support Linux Kernel source code.
On 2005, some split happened b.w linux kernel and BitProject which led the founder of Linux Kernel Linus Torvalds to 
develop a new DVCS with below things in mind - 
	> Speed
	> Simple Design
	> Strong Support for non-linear development i.e. thousands of parallel branches
	> Fully Distributed
	> Ability to handle large projects like Linux Kernel (in which the world is running its software/apps) efficiently
So folks!! this is how Git was born. 
Easy and yet humangously efficient.

Git basics 
It is suggested to "CLEAR your mind with all the things you many know about VCS, and then start learning GIT"
Use command line of Git, coz command line provides all functionality of git, while GUI's mostly provides some sub sets of functionlity.
coz the user interface and what it does may look similar like other VCS but how it does is completely different way.

	> Snapshots, Not differences:
	  Other VCS - Treat the data as a set of files and track differences b.w. them.
	  v1	v2		v3		v4		v5
	  a	delta1		-		delta2		-	
	  b	-		delta1		-		delta2	  

	  Git - Treats the data as a set of snapshots of a minature filesystem.
		So,
		    When you commit in Git(checkin), it basically takes a picture of what all your files like at that
		    moment and stores the referrence to that snapshot. And if the file has not changed, then git does 
		    not store that file again. It just makes a link to that old versioned file it had once stored on change.
	  v1	v2		v3		v4		v5
	  a	a1		a1		a2		a2
	  b	b		b		b1		b2

	> Nearly Every Operational is Local(no central dependency), You can work offline
	  You are not dependent on external network, external central server. Everything that you need to about your souce, from 
	  history of changes to who checked in and what is there in your local. You do not need to login to a particular instance
	  or gui to check what is the history and all the stuffs, you have everything at your local. You do not need a internet 
	  connection or network or server availability to know about your project. 
	  For eg in some older VCS, you made your changes offline but you can not commit them since you are offline not connected 
	  to network. But in GIT, you can do this. 

	> Git has integrity - You can loose info in git. Your file cannot get corrupted. Everything in git is checksumed and 
			      then taken inside. No-one can manually change those checksums.
			      Mechanishm for checksuming in git is known as SHA-1 hash. 40 character string composed of 
			      hexadecimal characters(0-9, a-f). It is calculated based on contents of a file and directory struct
			      -ure in git. Git's database has data stored with these SHA-1 hash names instead of regular file names.

	> Git's three states - basic usage of local repo 
	  This is the main thing about git you need to know if you are using git.
	
	  Commited, modified and staged.
	  Commited - Your data is safely stored in your "local" database.
	  Modified - You have changed the file you have not commited to your database yet.
	  Staged   - Files in the staged states are the modified files which you have marked  which needs to go into your next commit.

	  So, we can come down to the below three now - 
	  working dir, .git directory and staging area.

	  .git directory - gits area. This place git keeps all the information it needs about your source code. 
                           When you clone a repository, this is what is created. Complete compressed git database.
          working dir    - When you pull out a version of a project. Git pulls that version from the compressed git db, .git.
	  	           So that you have a particular version of that project in your local working dir.
	  staging        - it is simply a file containing information about your modified files in your working dir which needs to
		 	   be commited. Good thing about staging is, you can check them in and discard completely also.
	  
	  1. modify files in working dir
	  2. stage the files, adding snapshot of the set of files in staging area
	  3. commit files, so that those changes are permanently made to git repo.

Installation
Linux - yum install git /apt-get install git
Windows/Mac - Installers are present
Or, you can build the git using make from scratch.

Basic Customizations
git config files are stored at 3 diff places: 
	/etc/gitconfig: config for every user on the system and their repos. (git config --system)
	~/.gitconfig or ~/.config/git/config: config specific to your user. (git config --global)
	.git/config: config specific to your git repo.

	Each level above overrides the above level. So .git/config will overwrite the values in /etc/gitconfig

	$ git config --global user.name "Alok Kumar Singh"        #your identity
	$ git config --global user.email mail.alok87@gmail.com    #your email 
	$ git config -l						  #see config list
or	$ git config --list
	$ git config user.name 					  #to see a single specific value    
	$ git help <verb>


------------------------------------------------------------------------------------------ 2. Git Basics

Here i will show you all the basics which you need for daily usage in git, all the basic commands. Thats all.

#Getting a git repository
	a. git init  - start tracking your existing project in git
	$ git init #initializes your current dir with git and creates a git db .git
	$ git add *.c #adds all the modified *.c files to the staging area
	$ git commit -m "Initial commit" #commits the staged files in git repository
	
	b. git clone - clones an repository from other server
	   Please take a key note here, the command is clone and not checkout. This commands completely gets the whole 
           project into your local with all the history and information it has. It is not only brining the source files 
           as it used to happen in CVCS. So you can do whatever with network dependecny with this repo now.
	$ git clone [URL]
        $ git clone https://github.com/alok87/learn.git
	$ git clone https://github.com/alok87/learn.git anynameyouwant
	  #Note: Here we have used a https:// protocol , you can use git:// or user@server:path/to/repo.git later explained.
	
#Lifecycle of the status of the files:
As you edit files, Git seems them as modified.
Untracked > Unmodified > Modified > Staged > Commited
	$ git status #Check the status of the files in your current repository.
	$ echo "Git tuts 15mis" > readme
	$ git status # you will see untracked file
        $ git add readme # this adds the read me to tracked and then staging area.
        $ echo "more" >> readme
	$ git status # you will see a modified file saying readme
	$ git add readme # this again adds the modifed file in the staging area.	
	$ cat .gitignore #the files which you put here wont be staged and commited, you can use RE to define files in it.
	  *.[oa] # do no track *.o and *.a files
	  !lib.a # do track lib.a even if *.a are said no
          README.test # ignore README.test

#Diff
	Difference you commited/staged.
	$ git diff 	    # It tells the difference in the files in your working area to the files which are staged.
	$ git diff --staged # It tells the difference in the files in your staging aread to the commited files.
	$ git commit -m "Commit comments"

#Commit	
	Commiting a new file.
	$ git add newfile
	$ git commit -m "commit 1" newfile
or,	$ git commit -a -m "commit 1" newfile # this is a shortcut to skip git add

#Remove
	Say if you want to remove a file which you staged.
	$ rm newfile
	$ git status #it will still show as Deleted in staging area
	$ git add --all #this will finally remove the newfile from the staging area
or,     $ git rm newfile #this is a shortcut for above 3 commands, it directly removes the files from working and staging area.
	$ git rm --cached README #Suppose you want to keep README in your working dir but not in staging area.

#Move
	Moving files around git.
	$ mv newfile newfileR
	$ git rm newfile
	$ git add newfileR      # Running these commands puts your renamed file in staging 
				# as git was not aware renmaing happened.
				# see the or, alternative for this below:	
or,	$ git mv newfile newfileR
	$ git status #you will see that git shows a renamed file in your staging area.
      
#Log
	$ git log		# To view your commit history, latest changeset first
	$ git log -p -2		# Introduce changes introduced to 2 commits
	$ git log --stat	# It shows the commit history telling how many lines were inserted and deleted.
	$ git log --pretty=oneline # Shows the pretty log history in one line, other options are also there.
	$ git log --pretty=format:"%h -> %an, %ar :%s" # show the history in your own format ##WowGitFeature
	$ git log --pretty=format:"%h -> %s" --graph 	# Shows graph of merging and branching history
		format options below:
		%H Commit hash
		%h Abbreviated commit hash
		%T Tree hash
		%t Abbreviated tree hash
		%P Parent hashes
		%p Abbreviated parent hashes
		%an Author name
		%ae Author e-mail
		%ad Author date (format respects the –date= option)
		%ar Author date, relative
		%cn Committer name
		%ce Committer email
		%cd Committer date
		%cr Committer date, relative
		%s Subject
	$ git log -<n> 	# Shows the last n commits.
	$ git log --since=2.weeks
	$ git log --untill=2014-01-14
	$ git log --author="Alok Kumar Singh"
	$ git log --grep="some keyword"

#Undo
	$ git commit -m "Changes i commited"
	$ git add forgottenfile
	$ git commit --amend #This will add the forgottenfile and check in the last commit again by allowing you to edit msg.

#Unstaging a mistakenly staged file
	$ ls
	a b
	$ git add *
	$ git status # shows that both a and b are ready to be commited, but you wanted only a to be commited and not b.
	$ git reset HEAD b # This removes the file b from the staging area.


#Unmodifying a modified file
	$ git status --s
	M a.file
	$ git status # gives you info how to unmodify the changed file to the state of the file in the last commit.
	$ git checkout -- a.file #This discards your modified changes and checkout the latest file from repo.

#Remotes
  show remote, add remote, remove remotes, manage remote branches, define them as being tracked or not.
	
  show remotes
	$ git remote
	origin			#This is the default name of the 
	$ git remote -v         #This gives you the URLs with which your remote is connected to.
	If a repository is connected to multiple remote repos then it will show the mutiple URLs here.
	eg:
	alok_remote 		https://guthub.com/alok87/learn.git
	vicky_remote	https://github.com/alok87/backup.git
	So we can pull contributions from multiple people, make changes and may be if access we can push it back to them.
  add, fetch, clone
        $ git remote add [shortname] [URL]
        $ git remote add alok87/learn https://github.com/alok87/learn.git
        $ git pull 	# This fetches the remote branch and merge it in your current branch.                                               
	$ git fetch 	# This fetches the remote branch and do not merge it in your current branch.
			# You have to manually merge it in current branch if needed.
        $ git clone https://github.com/alok87/learn.git 
			# This adds this remote repo to origin and fetches it to your current 
                        # branch if not present.
  push
	$ git push [remote-shortname] [branch-name]
	$ git push origin master       # If you want to push your master branch to your origin remote server.
	$ git push alok87/learn master # If you want to push your master branch to your alok87/origin server.

  rename, remove remotes 
	$ git remote rename alok87/learn alok87/newlearn
	$ git remote rm alok87/learn

#Tagging
	Tags are like labels in TFS.
	Tagging is a good feature in git which let you mark specific important times in history.
	Typically people use this feature to mark the release points of the projects.
	$ git tag #lists all the tags 
	$ git tag -l 'v23*' #it lists all the v23* tags only.
	
	There are two types of git tags:
		Lightweight: It is just a pointer to commit. Like a branch that does not change.
		Annonated:   It is full info tag which contains all the info about it like email, date, pointer-commit everything.
		Recommended to use annonated.

	$ git tag -a v2.0 -m "Chapter 2 read" # It creates a annonated tag with an associated message.
	$ git show v2.0 		      # It shows all the information about the tag v2.0
	$ git tag v3.0 			      # This is a lightweight tag, no other info apart from checksum commit is kept.
					      # Lightweight is light but not recommended.
	$ git tag -a v1.0 -m "Chap 1" 9edia   # This will help in tagging the repo for the old commit also.
        $ git push origin <tagname>	      # This pushes your tag to the remote server which is mapped with origin name.

	$ git push origin --tags	      # This pushes all your tags to the remote server.
					      # So now if someone else pulls your repo, he will have all the tags.
	$ git checkout -b Git_ProBook_v1.0 Git_ProBook_v1.0
					     # The above command checks out your tag in a new branch with the same name.
#Aliases
	$ git config --global alias.c commit # This is an alias for "git commit" to act as "git c"
	$ git config --global alias.unstage 'reset HEAD--'
					     # This sets the alias for unstaging
	$ git config --global alias.last 'log -1 HEAD' # This gives the last commit log
	$ git config --global alias.visual "!gitk"     # This runs the gitk own program that runs with git repo. 

------------------------------------------------------------------------------------------ 3. Git Branching
What is Branching? 
	Branching means you diverge from the main line of development and continue to do work without disturbing with that main line.
	Almost every VCS has some kind of branching support. But Git's branching model is a killer feature. 

Why is Git Branching model so special?
	Git branches in a very lightweight manner. 
	Branching operations are instantaneous. 
	Branching operations like switching b/w branches back and forth are super fast.
	Git encourages workflows(to be explained later) that branch and merge often, several times a day.
	Knowing branching in Git will change the way you develop software.

Branching in Git in a nutshell
	When you make a commit. Git stores a commit object that stores the pointer to the snapshot the staged content && it also
	contains the author, email and commit msg && it also contains pointers to the parent commits(if present)
		git_commit_obj  = pointer_to_snapshot_staged_content
		git_commit_obj += email, commitmsg, author'sname, 
		git_commit_obj += pointers to the parent/parents commit
	-------------------------------------------------------------------------------------------------------
	eg, we have three files in our repo
	a
	b
	c
	$ git add . 
		When you stage these files(a, b c)
		Git makes the SHA-1 hash checksums of each of the files and stores the versions of 
		the files in Git repo(git calls them BLOBS), and adds the checksums to the staging area.
	$ git commit -m "whatever" .
		When you commit. Git checksums each subdir and stores those tree objects in Git repo.
		Git then creates a commit object that has metadata and pointer to the root project tree.
		This helps re-creating the snapshot again if needed.
	
	Git repo has 5 objects now:
	Blob - Contents of each of your files.
	Tree - List the contents of the dir, and specifies which file names are stored as which blobs.
	Commit - One commit object that stores the pointer to that root tree and all the commit metadata.

	Commit:98ca9	-->	Tree:92ec2          ----->	blob 5dl12, all contents of file
	tree	 92ec2		blob 5dl12 a    ----|---->	blob 5dl13, all contents of file      
	author	 alok           blob 5dl13 b	    ----->      blob 5dl14, all contents of file
	parent			blob 5dl14 c	
	commiter alok           		
	type     initial-commit
		
	So now, if you make some changes to some files and commit again. Suppose you changed file a and c.
	In Git, Each commit is a snapshot.
	You can see in the new commit, the parent is kept as a pointer to the old commit. New commit points to new tree
	which in turn will have new blob values.

						HEAD 		
						|
					        -----
					            V
					     v1.0   master
		------------------------------       ---  
		|				     |
		V				     V
											
	Commit:98ca9			Commit:98ca10	
	tree	 92ec2			tree 	 92ec3
	author   alok		<---    author   alok
	parent  			parent   98ca9 	
	commiter alok			commiter alok
	type     initial-commit         type 	 some-changes
		|				|
		|				|
		V				V
	  Snapshot A			  Snapshot B

	A branch in Git is a simple lightweight pointer to one of these commits.
	Default branch name is Master. As you commits, each commit object starts getting attached to the previous one.
	master <- commit1 <- commit2 and so on....
	
	Here branch v1.0 is behind of master branch by 1 commit.
	A new branch creates a new pointer for you to move around.
	Here head points to the master branch. So master is the current branch. 
	
	------------------------------------------------------------------------------------------------------------------
	
     #Creating a new branch
	Well creating a new branch creates a new pointer for you to move around.

	$ git status	  # Showed your current branch was "master" which is by default on doing git init.
			  # Git knows about your current branch by seeing where HEAD points to.
	$ git branch test # This created a branch test at the same commit you are currently on your current branch(master)
			  # Note this command only created a new branch, you are still in your HEAD pointer pointing branch.
	
	98ca7  <--- 98ca8  <-- 98ca9
		        	master   <-- HEAD
				test
	$ git log --oneline --decorate # this give the above diagram which you see here.
	98ca9 (HEAD, master, test) commit info
	98ca8 commit info
	98ca7 commit info
      
     #Switching to an existing branch 
	$ git checkout test # This switches your current branch to test and HEAD pointer is now pointing to test.
	98ca7  <--- 98ca8  <-- 98ca9
                                master  
                                test      <-- HEAD
		
	Now make a change to a file and commit(commit id say 98ca10)
	98ca7  <--- 98ca8  <-- 98ca9   <--  98ca10
                                master      
                                             test      <-- HEAD
		 
 	Now let's switch back to master branch.
	$ git checkout master
	98ca7  <--- 98ca8  <-- 98ca9   <--  98ca10
                                master                 <-- HEAD             
                                             test      		
        # This latest checkout of master, did two things:
		a. Moved the pointer of HEAD to point to master.
		b. Reverted back your 98ca10 changes, by checking out the snapshot 98ca9 points to.		
	
	Now again if you make a change and commit(say commit id 98ca11)
				------------98ca11
				V	    master    <--- HEAD
	98ca7  <--- 98ca8  <-- 98ca9   <--  98ca10
                                             test
	So now your branches(master and test) have diverged from each other and have their own development path.
eg:	[root@centdev01 tmp]# git log --oneline --decorate
	746e8cf (HEAD, master) Checked in e in branch master
	2d28b57 commit 1
	[root@centdev01 tmp]# git checkout slave
	Switched to branch 'slave'
	[root@centdev01 tmp]# git log --oneline --decorate
	199134a (HEAD, slave) Checked in d in slave branch
	2d28b57 commit 1	

	$ git log --oneline --decorate --graph --all #shows where your branch pointers are and how your history has diverged.

	SUMMARY:	
	SO BRANCH IN A GIT IS A SIMPLE FILE THAT CONTAINS THE 40 char SHA-1 checksum of the commit it points to.
	SO BRANCHES ARE CHEAP TO DESTROY AND CREATE AND MOVE AROUND. 
	CREATING A BRANCH IS AS QUICK AS WRITING THAT 40char and a newline in a file. 
	THIS FEATURE OF GIT IS IN SHARP CONTRAST TO OTHERS WHERE FOR CREATING A NEW BRANCH THE COMPLETE DATA WAS COPIED
	TO ANOTHER DIRECTORY AND THEN IT WAS CHECKED IN, MAKING IT HEAVY.
	FINDING A MERGE POINT AND WORKING ON IT ALL BECOMES EASY BECAUSE OF GIT STORES THE POINTERS TO THEIR PARENT COMMITS.

Basic Merging and Branching     
	
	$ git status
	# On branch master
	$ git checkout -b "iss53"	# You created a branch iss53 to work on the issue-53.
				 	# You created and switched to that branch using this command.
					# Shorthand for: git branch iss53; git checkout iss53
	$ git status
	# On branch iss53
	$ touch bb53 cc53 dd53		# You created new files to try fixing the issue53.
	$ git checkout master		# You got a call suddenly to fix an issue in master production branch. 
					# So you checked out master branch to do a hotfix for prod.
	$ git checkout -b hotfix 	# So you create a new branch to work on the hotfix from the current master.
	$ git status
	# On branch hotfix
	$ touch hotfix_prod_52		# You make your production fix in the hotfix branch. 
	$ git commit -a -m "Urgent production fix" 
					# You checked in your changes.
					# Now do your tests in hotifix branch to verify all is good.
					# If all looks good, merge your changes to the master production branch to deploy to prod 
					  after build.
#merge
 #fast-forward
        $ git checkout master
       	$ git merge hotfix
	'Fast-forward' strategy.	# Fast-forward means Git simplified the merge operations as it found that the master was
					  only 1 commit behind and rest everything was same. So it just moved the pointer to new
					  commit.
		
	c1	c2 < master
			c3	c4 < iss53
	*fast-forward merge was performed as the iss53 was only 2 commits ahead after c2. So git just moved
	*the master branch pointer to c4 for performing the merge operation. Thats it, so fast-forward

	$ git branch -d hotfix		# You delete the hotfix branch as it is no longer needed.
	$ git checkout issue-53  
	$ git add . && git commit -m "checked in issue 53 fix"
                                        # You fixed and checked in your changes in this branch.
                                        # Now the iss53 branch has moved ahead of master branch remember.
	$ git checkout master           # Now you have decided that iss53 is fixed and should be merged to master
					# Checkout the branch you want to merge into

 #recursive
	$ git merge iss53		# Merge the branch you want to merge
	Merge made by the 'recursive' strategy.
	Note: The merge was made by recursive strategy now.
	# Since the main branch had also moved ahead.	
			
			
	c1	c2	c3 < master
			c4	c5 < iss53
			



	




						




 
